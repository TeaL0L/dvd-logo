<html><head><base href=".">
<style>
body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(45deg, #000000, #1a1a1a);
    position: relative;
    width: 100vw;
    height: 100vh;
}

body::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 30% 40%, rgba(255,0,0,0.05) 0%, transparent 50%),
        radial-gradient(circle at 70% 60%, rgba(0,0,255,0.05) 0%, transparent 50%);
    animation: backgroundPulse 10s ease-in-out infinite;
    z-index: 0;
}

@keyframes backgroundPulse {
    0%, 100% { transform: scale(1); opacity: 0.5; }
    50% { transform: scale(1.2); opacity: 0.8; }
}

.dvd-logo {
    position: absolute;
    width: 200px;
    height: 100px;
    will-change: transform;
    transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    filter: drop-shadow(0 0 10px currentColor);
}

#logo {
    width: 100%;
    height: 100%;
    fill: currentColor;
    animation: color-change 5s infinite;
    will-change: color;
}

@keyframes color-change {
    0% { color: #ff0000; filter: drop-shadow(0 0 10px #ff0000); }
    20% { color: #00ff00; filter: drop-shadow(0 0 10px #00ff00); }
    40% { color: #0000ff; filter: drop-shadow(0 0 10px #0000ff); }
    60% { color: #ffff00; filter: drop-shadow(0 0 10px #ffff00); }
    80% { color: #ff00ff; filter: drop-shadow(0 0 10px #ffff00); }
    100% { color: #ff0000; filter: drop-shadow(0 0 10px #ff0000); }
}

.toggle-container {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 15px;
    color: white;
    font-family: Arial, sans-serif;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 20px rgba(0, 0, 255, 0.2);
    padding: 15px;
    border-radius: 10px;
    transition: all 0.3s ease;
}

.toggle-container:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 25px rgba(0, 0, 255, 0.3);
    background: rgba(0, 0, 0, 0.9);
}

.switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 30px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
    transition: .4s;
    border-radius: 30px;
    box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 4px;
    bottom: 3px;
    background: linear-gradient(45deg, #ffffff, #f0f0f0);
    transition: .4s;
    border-radius: 50%;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
}

input:checked + .slider {
    background: linear-gradient(45deg, #2196F3, #21CBF3);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

input:checked + .slider:before {
    transform: translateX(30px);
}

#bounce-counter {
    font-size: 16px;
    display: none;
    margin-left: 10px;
    background: linear-gradient(45deg, #2196F3, #21CBF3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: bold;
}

#target-bounces-display {
    color: white;
    font-family: Arial, sans-serif;
    font-weight: bold;
    background: linear-gradient(45deg, #2196F3, #21CBF3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

#set-bounces-btn {
    background: linear-gradient(45deg, #2196F3, #21CBF3);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-family: Arial, sans-serif;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
    text-transform: uppercase;
    letter-spacing: 1px;
    font-size: 14px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

#set-bounces-btn:hover {
    background: linear-gradient(45deg, #21CBF3, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 0 20px rgba(33, 150, 243, 0.5);
}

#set-bounces-btn:active {
    transform: translateY(1px);
    box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
}

#corner-hits {
    position: fixed; 
    top: 20px; 
    right: 20px; 
    color: white; 
    font-family: Arial, sans-serif; 
    font-size: 24px; 
    z-index: 1000;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    padding: 10px 20px;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
    transition: all 0.3s ease;
}

#corner-hits:hover {
    transform: scale(1.05);
}

#toggle-label {
    font-weight: bold;
    letter-spacing: 0.5px;
    background: linear-gradient(45deg, #ffffff, #cccccc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

#total-bounces {
    position: fixed; 
    top: 80px; 
    right: 20px; 
    color: white; 
    font-family: Arial, sans-serif; 
    font-size: 24px; 
    z-index: 1000; 
    background: rgba(0, 0, 0, 0.8); 
    backdrop-filter: blur(10px); 
    padding: 10px 20px; 
    border-radius: 15px; 
    border: 1px solid rgba(255, 255, 255, 0.1); 
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); 
    transition: all 0.3s ease;
}
</style>
</head>
<body>

<div class="toggle-container">
    <div style="display: flex; align-items: center; gap: 10px;">
        <label class="switch">
            <input type="checkbox" id="corner-toggle">
            <span class="slider"></span>
        </label>
        <span id="toggle-label" style="color: white; font-family: Arial, sans-serif;">Show Bounces Until Corner</span>
        <div id="bounce-counter">Bounces until corner: <span id="bounce-count">calculating...</span></div>
    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
        <button id="set-bounces-btn" class="speed-preset">Set Target Bounces</button>
        <span id="target-bounces-display"></span>
    </div>
</div>

<div id="corner-hits">
    Corner Hits: <span id="hits-count">0</span>
</div>

<div id="total-bounces">
    Total Bounces: <span id="bounces-count">0</span>
</div>

<div class="dvd-logo">
    <svg id="logo" viewBox="0 0 210 107" xmlns="http://www.w3.org/2000/svg">
        <path d="M118.895,20.346c0,0-13.743,16.922-13.04,18.001c0.975-1.079-4.934-18.186-4.934-18.186s-1.233-3.597-5.102-15.387H81.81H47.812H22.175l-2.56,11.068h19.299h4.579c12.415,0,19.995,5.132,17.878,14.225c-2.287,9.901-13.123,14.128-24.665,14.128H32.39l5.552-24.208H18.647l-8.192,35.368h27.398c20.612,0,40.166-11.067,43.692-25.288c0.617-2.614,0.53-9.185-1.054-13.053c0-0.093-0.091-0.271-0.178-0.537c-0.087-0.093-0.178-0.722,0.178-0.814c0.172-0.092,0.525,0.271,0.525,0.358c0,0,0.179,0.456,0.351,0.813l17.44,50.315l44.404-51.216l18.143-0.092h4.052c12.416,0,20.09,5.132,17.969,14.225c-2.29,9.901-13.205,14.128-24.75,14.128h-4.317l5.553-24.208h-19.207l-8.192,35.368h27.396c20.611,0,40.343-11.067,43.604-25.288c3.347-14.225-11.101-25.293-31.89-25.293h-18.143h-22.727C120.923,17.823,118.895,20.346,118.895,20.346L118.895,20.346z"/>
        <path d="M99.424,67.329C47.281,67.329,5,73.449,5,81.012c0,7.558,42.281,13.678,94.424,13.678c52.239,0,94.524-6.12,94.524-13.678C193.949,73.449,151.664,67.329,99.424,67.329z M96.078,85.873c-11.98,0-21.58-2.072-21.58-4.595c0-2.523,9.599-4.59,21.58-4.59c11.888,0,21.498,2.066,21.498,4.59C117.576,83.801,107.966,85.873,96.078,85.873z"/>
    </svg>
</div>

<script>
let totalBounces = 0;
const bouncesDisplay = document.getElementById('bounces-count');

// Create audio context and oscillator for achievement sound
let audioCtx;

function createYippeeSound() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // Main celebratory tone
    const osc1 = audioCtx.createOscillator();
    const gain1 = audioCtx.createGain();
    
    // Harmonizing tone
    const osc2 = audioCtx.createOscillator();
    const gain2 = audioCtx.createGain();
    
    // Sparkle/achievement effect
    const osc3 = audioCtx.createOscillator();
    const gain3 = audioCtx.createGain();

    // Triumph effect
    const osc4 = audioCtx.createOscillator();
    const gain4 = audioCtx.createGain();

    // Master volume control
    const masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(0.1, audioCtx.currentTime); // Reduced overall volume

    // Main ascending tone (achievement sound)
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(392, audioCtx.currentTime); // G4
    osc1.frequency.exponentialRampToValueAtTime(784, audioCtx.currentTime + 0.15); // G5
    
    // Harmonizing tone
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(587.33, audioCtx.currentTime); // D5
    osc2.frequency.exponentialRampToValueAtTime(1174.66, audioCtx.currentTime + 0.2); // D6
    
    // Sparkle effect (high frequency chime)
    osc3.type = 'sine';
    osc3.frequency.setValueAtTime(1568, audioCtx.currentTime); // G6
    osc3.frequency.exponentialRampToValueAtTime(2637.02, audioCtx.currentTime + 0.25); // E7

    // Triumph effect (lower supportive tone)
    osc4.type = 'triangle';
    osc4.frequency.setValueAtTime(196, audioCtx.currentTime); // G3
    osc4.frequency.exponentialRampToValueAtTime(392, audioCtx.currentTime + 0.3); // G4

    // Volume envelopes for smooth transitions
    gain1.gain.setValueAtTime(0, audioCtx.currentTime);
    gain1.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.05);
    gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
    
    gain2.gain.setValueAtTime(0, audioCtx.currentTime);
    gain2.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.1);
    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
    
    gain3.gain.setValueAtTime(0, audioCtx.currentTime);
    gain3.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.15);
    gain3.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

    gain4.gain.setValueAtTime(0, audioCtx.currentTime);
    gain4.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
    gain4.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.45);

    // Connect all oscillators through their gains to master volume
    osc1.connect(gain1);
    osc2.connect(gain2);
    osc3.connect(gain3);
    osc4.connect(gain4);
    gain1.connect(masterGain);
    gain2.connect(masterGain);
    gain3.connect(masterGain);
    gain4.connect(masterGain);
    masterGain.connect(audioCtx.destination);
    
    // Start and stop oscillators
    osc1.start(audioCtx.currentTime);
    osc2.start(audioCtx.currentTime);
    osc3.start(audioCtx.currentTime);
    osc4.start(audioCtx.currentTime);
    osc1.stop(audioCtx.currentTime + 0.5);
    osc2.stop(audioCtx.currentTime + 0.5);
    osc3.stop(audioCtx.currentTime + 0.5);
    osc4.stop(audioCtx.currentTime + 0.5);
}

function playCornerHitSound() {
    createYippeeSound();
}

const logo = document.querySelector('.dvd-logo');
const cornerToggle = document.getElementById('corner-toggle');
const bounceCounter = document.getElementById('bounce-counter');
const bounceCountDisplay = document.getElementById('bounce-count');
const setBounceBtn = document.getElementById('set-bounces-btn');
const targetBouncesDisplay = document.getElementById('target-bounces-display');
const cornerHitsDisplay = document.getElementById('hits-count');
let cornerHits = 0;

let isCornerPredictionEnabled = false;

let x = Math.random() * (window.innerWidth - 200);
let y = Math.random() * (window.innerHeight - 100);
let baseXSpeed = 3;
let baseYSpeed = 2;
let speedMultiplier = 1;
let xDirection = 1;
let yDirection = 1;
let lastPositionWasCorner = false;

let xSpeed = baseXSpeed * xDirection;
let ySpeed = baseYSpeed * yDirection;
let targetBounces = null;

cornerToggle.addEventListener('change', (e) => {
    isCornerPredictionEnabled = e.target.checked;
    bounceCounter.style.display = isCornerPredictionEnabled ? 'block' : 'none';
    document.getElementById('toggle-label').style.display = isCornerPredictionEnabled ? 'none' : 'block';
});

function isCorner(x, y, maxX, maxY) {
    const CORNER_THRESHOLD = 1;
    const rightEdge = maxX || (window.innerWidth - logo.offsetWidth);
    const bottomEdge = maxY || (window.innerHeight - logo.offsetHeight);
    return (
        (Math.abs(x) <= CORNER_THRESHOLD && Math.abs(y) <= CORNER_THRESHOLD) ||
        (Math.abs(x - rightEdge) <= CORNER_THRESHOLD && Math.abs(y) <= CORNER_THRESHOLD) ||
        (Math.abs(x) <= CORNER_THRESHOLD && Math.abs(y - bottomEdge) <= CORNER_THRESHOLD) ||
        (Math.abs(x - rightEdge) <= CORNER_THRESHOLD && Math.abs(y - bottomEdge) <= CORNER_THRESHOLD)
    );
}

function findPositionForTargetBounces(targetBounces) {
    const maxX = window.innerWidth - logo.offsetWidth;
    const maxY = window.innerHeight - logo.offsetHeight;
    
    for(let attempts = 0; attempts < 1000; attempts++) {
        let testX = Math.random() * maxX;
        let testY = Math.random() * maxY;
        
        let testDX = Math.random() < 0.5 ? -baseXSpeed : baseXSpeed;
        let testDY = Math.random() < 0.5 ? -baseYSpeed : baseYSpeed;
        
        const bouncesNeeded = predictBouncesToCorner(
            testX, testY,
            testDX, testDY,
            window.innerWidth,
            window.innerHeight,
            logo.offsetWidth,
            logo.offsetHeight
        );
        
        if (bouncesNeeded !== "∞" && bouncesNeeded === targetBounces) {
            return {
                x: testX,
                y: testY,
                xDirection: Math.sign(testDX),
                yDirection: Math.sign(testDY)
            };
        }
    }
    return null;
}

setBounceBtn.addEventListener('click', () => {
    const userInput = prompt('Enter desired number of bounces to corner:');
    if (userInput !== null && !isNaN(userInput)) {
        targetBounces = parseInt(userInput);
        targetBouncesDisplay.textContent = `Target: ${targetBounces} bounces`;
        
        const position = findPositionForTargetBounces(targetBounces);
        if (position) {
            x = position.x;
            y = position.y;
            xDirection = position.xDirection;
            yDirection = position.yDirection;
            xSpeed = baseXSpeed * xDirection;
            ySpeed = baseYSpeed * yDirection;
            speedMultiplier = 1;

            logo.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        } else {
            alert('Could not find a valid position for the requested number of bounces. Please try a different number.');
        }
    }
});

function predictBouncesToCorner(x, y, dx, dy, width, height, logoWidth, logoHeight) {
    const maxX = width - logoWidth;
    const maxY = height - logoHeight;
    const PRECISION = 0.0001;

    let currentX = x;
    let currentY = y;
    let currentDX = Math.sign(dx) * baseXSpeed;
    let currentDY = Math.sign(dy) * baseYSpeed;
    let bounces = 0;
    const MAX_ITERATIONS = 10000;

    while (bounces < MAX_ITERATIONS) {
        let timeToXCollision = currentDX > 0 ? 
            (maxX - currentX) / currentDX : 
            -currentX / currentDX;
        let timeToYCollision = currentDY > 0 ? 
            (maxY - currentY) / currentDY : 
            -currentY / currentDY;

        let timeToCollision = Math.min(timeToXCollision, timeToYCollision);
        
        let nextX = currentX + currentDX * timeToCollision;
        let nextY = currentY + currentDY * timeToCollision;
        
        nextX = Math.max(0, Math.min(maxX, nextX));
        nextY = Math.max(0, Math.min(maxY, nextY));

        if (isCorner(nextX, nextY, maxX, maxY)) {
            return bounces;
        }

        currentX = nextX;
        currentY = nextY;

        if (Math.abs(timeToXCollision - timeToCollision) < PRECISION) {
            currentDX = -currentDX;
        }
        if (Math.abs(timeToYCollision - timeToCollision) < PRECISION) {
            currentDY = -currentDY;
        }

        bounces++;
    }

    return "∞";
}

function animate() {
    const maxX = window.innerWidth - logo.offsetWidth;
    const maxY = window.innerHeight - logo.offsetHeight;
    
    const nextX = x + xSpeed * speedMultiplier;
    const nextY = y + ySpeed * speedMultiplier;

    if (nextX >= maxX || nextX <= 0) {
        xDirection *= -1;
        xSpeed = baseXSpeed * xDirection;
        x = nextX >= maxX ? maxX : 0;
        totalBounces++; // Add bounce counter
        bouncesDisplay.textContent = totalBounces; // Update display
    } else {
        x = nextX;
    }

    if (nextY >= maxY || nextY <= 0) {
        yDirection *= -1;
        ySpeed = baseYSpeed * yDirection;
        y = nextY >= maxY ? maxY : 0;
        totalBounces++; // Add bounce counter
        bouncesDisplay.textContent = totalBounces; // Update display
    } else {
        y = nextY;
    }

    logo.style.transform = `translate3d(${x}px, ${y}px, 0)`;

    const currentlyInCorner = isCorner(x, y, maxX, maxY);
    if (currentlyInCorner && !lastPositionWasCorner) {
        playCornerHitSound();
        cornerHits++;
        cornerHitsDisplay.textContent = cornerHits;
    }
    lastPositionWasCorner = currentlyInCorner;

    if (isCornerPredictionEnabled) {
        const bouncesLeft = predictBouncesToCorner(
            x, y, 
            xSpeed,
            ySpeed,
            window.innerWidth, 
            window.innerHeight, 
            logo.offsetWidth, 
            logo.offsetHeight
        );
        bounceCountDisplay.textContent = bouncesLeft;
    }
    
    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    const maxX = window.innerWidth - logo.offsetWidth;
    const maxY = window.innerHeight - logo.offsetHeight;
    x = Math.min(x, maxX);
    y = Math.min(y, maxY);
});

document.addEventListener('click', () => {
    // Removed YouTube player interaction
});

</script>

</body></html>
